\documentclass[brudnopis]{xmgr}

%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Minion Pro}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Myriad Pro}
%\setmonofont[Scale=0.75]{Monaco}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{minted}
\usepackage{caption}
% Opcjonalnie identyfikator dokumentu
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Oskar Plichta}
\nralbumu {195009}
\email    {oskar.plichta22@gmail.com}


\title    {Budowa aplikacji modularnej do udostępniania fotografii  w web 3.0}
\date     {2015}
\miejsce  {Gdańsk}

\opiekun  {dr W. Bzyl}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}

\begin{document}

\begin{abstract}

W pracy zostanie przedstawiony program do udostępniania fotografii na kilka serwisów społecznościowych jednocześnie z intuicyjnym interfejsem Material Design. Dzięki temu w prosty i szybki sposób można podzielić się swoimi zdjęciami z innymi użytkownikami kilku sieci społecznościowych. Aplikacja będzie wykonana z dwóch modułów - części serwerowej i wizualnej. Część serwerowa jest oparta o \textit{Ruby on Rails} a wizualna wykonana w \textit{EmberJS} oraz \textit{Materialize}. Aplikacje mobilna dla systemu Android wykonane zostały dzięki aplikacji \textit{Cordova}, która pozwala przekształcić aplikację opartą o \textit{EmberJS} oraz \textit{Ember CLI} w natywną aplikacje dla danego systemu mobilnego. Ostatecznie aplikacja została wykonana zgodnie z założeniami i spełnia wyznaczone cele.

\end{abstract}
\keywords{\textit{User Interface, Material Design, Ruby on Rails, EmberJS, PostgreSQL, RSpec, Jasmine}}

% tytuł i spis treści
\maketitle
%
% wstęp
\introduction
\indent Fotografie są jednym z najczęstszych typów danych przesyłanych w Web 3.0. Gwałtowny rozrost sieci społecznościowych spowodował, że prawie każdy udostępnia zdjęcia aby podzielić się nimi z rodziną i przyjaciółmi. Temat wysyłania zdjęć do kilku serwisów jednocześnie, tak aby nie jeszcze raz nie powtarzać tej samej czynności na innym serwisie społecznościowym, pozostaje otwarty i dlatego postanowiłem go zgłębić.
\newline\indent Portale takie jak Facebook, Flickr czy Twitter prześcigają się w tym aby wysyłanie zdjęć na ich serwer było jak najprostsze. Większość z nich pozwala na tzw. drag and drop\footnote{ang. \textit{drag and drop} - przeciągnij i upuść} fotografii oraz na wysyłanie ich do innych serwisów. Zakładając, że mamy zdjęcia z wakacji i chcemy je udostępnić na Facebooku oraz umieścić na naszym koncie Flickr w celu archiwizacji musimy zalogować się na Facebooka, następnie wysłać zdjęcia na serwer Facebooka, ewentualnie dopisać opis i kliknąć w przycisk do udostępniania, po czym całość powtórzyć na serwisie Flickr.Aplikacja, którą opisuje w tej pracy pozwala na jednoczesne wysyłanie zdjęć na kilka serwisów społecznościowych za pomocą kilku kliknięć. Wystarczy wybrać zdjęcia dzięki drag and drop, zalogować się na wybrane przez nas serwisy a następnie kliknąć wyślij. Wszystko przebiega szybko i sprawnie a my oszczędzamy nasz czas.  Aplikacja ta jest tzw. aplikacją modułową co znaczy, że w przeciwieństwie do aplikacji monolitycznej, składa się z  niezależnych od siebie części tj. serwerowej oraz wizualnej. Obie części komunikują się ze sobą za pomocą wiadomości JSON. Część serwerowa odpowiada za komunikację z bazą danych, komunikację z serwerami zewnętrznymi oraz autoryzację użytkowników i wysyłanie danych do front-endu czyli aplikacji wizualnej. Zostanie ona wykonana w języku Ruby i frameworku \textit{Ruby on Rails}.   Aplikacja wizualna, która zostanie wykonana w języku JavaScript i frameworku \textit{EmberJS}, ma za zadanie wyświetlanie danych w przystępnej formie dla użytkownika poprzez tzw. interfejs. Omówię zagadnienie aplikacji modularnej i monolitycznej bardziej szczegółowo w jednym z kolejnych rozdziałów. Interfejs użytkownika \footnote{ang. \textit{User Interface} - UI}  jest podstawowym sposobem komunikacji pomiędzy człowiekiem a maszyną dlatego tak ważne jest, aby był on intuicyjny i przyjazny dla użytkownika. Postaram się pokazać dlaczego UI w mojej aplikacji jest przyjazny, intuicyjny dla użytkownika i pozwala mu na wydajną pracę a wszystko dzięki wytycznym Google Material Design, które jest nowym designem dla aplikacji od firmy Google. Więcej na temat Material Design oraz interfejsu aplikacji PicDrop w kolejnych rozdziałach.\newline \indent Większość smartphonów posiada dobrej jakości aparaty, zarówno z przodu jak i z tyłu urządzenia, dlatego w każdej chwili możemy wysłać zdjęcia z dowolnego miejsca do rodziny i przyjaciół poprzez sieci społecznościowe, za pomocą natywnej aplikacji na dany system mobilny. Dzięki temu, że moja aplikacja jest modułowa, jej część serwerowa czyli API pozwala na połączenie z nią różnych części wizualnych tzw. front-end z systemów mobilnych takich jak np. iOS lub Android. Jest to możliwe dzięki aplikacji Cordova, która zamienia aplikację \textit{EmberJS} w natywną aplikację na dany system mobilny przez co jest ona łatwiejsza w obsłudze i lepiej wykorzystuje mały wyświetlacz smartphona niż aplikacja przeglądarkowa. Opiszę dokładniej ten proces w odpowiednim rozdziale oraz podam inne zalety aplikacji natywnej. Wskażę również z jakimi problemami musi się uporać \textit{developer} aplikacji webowych, aby jego aplikacja była intuicyjna i funkcjonalna. Wyjaśnię, które elementy mojej aplikacji testuję i w jaki sposób. Opierając się na  doświadczeniach innych badaczy  między innymi Roberta Hoekmana jr  \cite {magiaUI} oraz Jenifer Tidwell  \cite {projektowanieUI}, którzy opisali swoje spostrzeżenia w ich książkach, postaram się napisać aplikacje PicDrop, która  będzie miała przyjazne UI i pozwoli na łatwe udostępnianie treści. Opiszę dlaczego wybrałem \textit{EmberJS}, \textit{MaterializeCSS} oraz \textit{Ruby on Rails} do stworzenia tej aplikacji i dlaczego te technologie uważam za najlepszy wybór.


\chapter{Budowa aplikacji modularnej do udostępniania fotografii  w web 3.0}

\section{Porównanie dostępnych rozwiązań}
Każdy serwis społecznościowy posiada swoje możliwości udostępniania zdjęć, które ograniczają się do jednego serwisu. Tak więc jeśli chcemy wgrać swoje zdjęcia jednocześnie na Facebooka, żeby zobaczyli je nasi znajomi oraz Flickr w celu archiwizacji to musimy je wgrać na jeden z tych dwóch serwisów a następnie na kolejny. Takie rozwiązanie zajmuje dużo czasu i jest niekorzystne dla użytkownika. Serwis Facebook, który jest najpopularniejszym serwisem społecznościowym, zrzesza ponad 500 milionów użytkowników. Udostępnianie zdjęć poprzez ten serwis polega na kliknięciu w ikonkę zdjęcia i wybraniu danego pliku, bądź przeciągnięciu i upuszczeniu pliku w odpowiednim miejscu. Możemy dopisać, krótki tekst i po naciśnięciu guzika wyślij, post pojawi się na naszej tablicy. Facebook nie pozwala na udostępnianie zdjęć poza swoją stroną, także jeżeli mamy znajomych nie posiadających konta na tym serwisie to nie zobaczą oni naszych zdjęć. \newline \indent \textit{Flickr} jest serwisem dla miłośników fotografii, który daje nam, aż 1 TB na przechowywanie naszych zdjęć. Pozwala on również na udostępnianie plików także do innych serwisów społecznościowych. Umieszczanie zdjęć w tym serwisie jest podobne do rozwiązania stosowanego w Facebooku, to znaczy albo wybieramy pliki albo przeciągamy je do okna przeglądarki. Po wgraniu ich na serwer możemy je udostępnić dalej poprzez wybranie zdjęć. Aktualnie nie ma serwisu, który by pozwalał na wysyłanie zdjęć do dwóch serwisów jednocześnie. Z tego powodu postanowiłem stworzyć aplikację, która zmienia ten stan rzeczy.
\section{Możliwości zastosowania praktycznego}
Głównym celem aplikacji \textit{PicDrop} jest proste i intuicyjne udostępnianie fotografii. Użytkownik może wgrać własne fotografie poprzez przeciągniecie do okna przeglądarki, gdzie zobaczy miłą dla oka animację pulsującego koła. Gdy upuści wybrane zdjęcia pokażą się miniatury zdjęć. Następnie wystarczy, że użytkownik kliknie guzik z symbolem portalu gdzie chce udostępnić swoje fotografie i zaloguje się na wybrany portal społecznościowy. Później jedno kliknięcie wysyła asynchronicznie wszystkie zdjęcia na serwery \textit{Flickra} i \textit{Facebooka}. To wszystko. Obsługa jest szybka i intuicyjna. Gdybyśmy stwierdzili, że nie chcemy wysyłać jednego ze zdjęć możemy je usunąć klikając ikonę kosza. Zdjęcia można powiększać, klikając na nie. Funkcja ta może być szczególnie przydatna gdy zdjęcie ma dużo detali a my chcemy mu się dokładniej przyjrzeć. Można także udostępnić pojedyncze zdjęcie klikając na  odpowiednią ikonę. Aplikacja ma piękny design oparty o \textit{Material Design} od firmy \textit{Google} dlatego korzystanie z niej jest miłe dla oka. Dzięki tej aplikacji możemy zaoszczędzić czas gdy chcemy szybko udostępnić zdjęcia znajomym a jednocześnie zapisać je na serwerach dla archiwizacji.

\chapter{Projekt i analiza}
\section{Aktorzy i przypadki użycia, wymagania funkcjonalne i niefunkcjonalne}
Aplikacja wczytuje zdjęcia z bazy danych PostgreSQL, wysyła je przez JSON do klienta i tam EmberJS odpowiednio obrabia dane pokazując je w formie przyjaznej użytkownikowi. Następnie, gdy chcemy udostępnić jakiś plik to jest to obsługiwane także przez EmberJS, tak aby komunikacja była szybka i niezawodna. Jednakże jeśli użytkownik wczytuje własne zdjęcia, które chce udostępnić to są one zamieniane na ciąg znaków w standardzie Base64Image i wysyłane wiadomością JSON do API. Tam back-end łączy się z wybranym portalem społecznościowym i przesyła do niego zdjęcia.
\begin{minted}[frame=single, fontsize=\normalsize, breaklines=true]{js}
kod function(){}
\end{minted}

 Wymagania funkcjonalne aplikacji to: 
\begin{itemize}
  \item Użytkownik będzie mógł udostępniać fotografie. 
  \item Użytkownik będzie mógł się zalogować.
  \item Użytkownik będzie mógł wybrać serwis na jaki fotografie zostaną wysłane.
  \item Użytkownik będzie mógł usunąć wybrane fotografie
\end{itemize}

Wymagania niefunkcjonalne aplikacji to: 
\begin{itemize}
  \item Wszelka niezbędna komunikacja między serwerem a aplikacją kliencką powinna dać się wyrazić za pomocą wiadomości \textit{JSON}
  \item Interfejs aplikacji powinien być zgodny z wytycznymi \textit{Material Design}.
  \item Aplikacja nie powinna udostępniać osobom trzecim danych użytkowników zapisanych w bazie danych.
\end{itemize}
  
\section{Diagram klas}

\section{Diagram modelu danych}
\textit{PicDrop} posiada trzy modele danych. Są to \textit{User}, \textit{Photo} oraz \textit{Authorization}. Pierwszy z nich służy do obsługi danych uzytkownika i logowania do aplikacji. Zawiera on pola do zapisywania email, hasła, potwierdzenia hasła, token użytkownika oraz jego nazwę. Drugi natomiast jest modelem dla danych o wysyłanych zdjęciach, czyli na przykład nazwa, adres url oraz właściciela. Ostatni model przechowuje dane z kont społecznościowych. Zapisywane są w nim loginy, hasła oraz tokeny autoryzacji użytkowników. 
\section{Projekt interfejsu użytkownika w oparciu o framework Materialize}
	Interfejs użytkownika musi być czytelny i łatwy w obsłudze a jednocześnie pozwalać na wydajną pracę. W aplikacji \textit{PicDrop} główny nacisk położyłem na intuicyjność i szybkość działania. Do stworzenia designu aplikacji użyłem \textit{frameworka MaterializeCSS} opartym o \textit{Material Design} o którym więcej w kolejnym podrozdziale. \textit{MaterializeCSS} pozwala na używanie komponentów webowych, z których chcemy zbudować naszą aplikacje. Do wyboru mamy wiele różnych typów menu, kart, guzików, formularzy, panelów nawigacyjnych. Proponowana jest także paleta barw, tak aby strona spełniała założenia \textit{Material Design}. Framework ten odpowiada także za łatwe rozmieszczenie komponentów na stronie. Dzieje się tak poprzez tak zwany \textit{Grid}, który dzieli stronę na 12 kolumn co pozwala na zawijanie wierszy na urządzeniach mobilnych bez utraty treści i konieczności przewijania strony. \textit{UI} aplikacji jest także funkcjonalne. Dobrym przykładem jest wybieranie fotografii za pomocą upuszczenia ich w oknie przeglądarki internetowej. Głównymi komponentami użytymi w mojej aplikacji jest panel nawigacyjny u góry oraz karty z miniaturkami zdjęć. Poza tym użyłem pól formularzy oraz guzików, które po naciśnięciu wyświetlają tak zwaną fale, przez co użytkownik wie, że dany guzik został naciśnięty.
\subsection{Wytyczne odnośnie UI w Material Design}
Google Material Design został zaprezentowany pierwszy raz na Google I/O w 2014 roku wraz z systemem Android i jego wersją Lolipop.  Dzięki temu wszystkie aplikacje na platformę od \textit{Google’a} posiadają spójny wygląd. Wytyczne przedstawiają paletę barw, typografię, ikony, bardziej spójną hierarchię interfejsu oraz wszelkie zasady co i jak powinno się tworzyć. Mimo, że od tamtego wydarzenia minęło już trochę czasu to jest on używany przez Google w kolejnych edycjach systemu Android. Głównymi założeniami tego designu jest to że składa on się z kilku  nałożonych na siebie warstw papieru w różnych kolorach. Dzięki temu mamy wrażenie głębi a wszystko jest przejrzyste i intuicyjne. Wszystkie elementy Dodatkowo animacje w \textit{Material Design} dopasowują się do kolejnej wytycznej czyli do takiego animowania elementów na ekranie, żeby użytkownik miał najważniejsze elementy cały czas na widoku a nie, żeby one pojawiały się znikąd. 

\chapter{Architektura aplikacji PicDrop}
Aplikacja składa się z dwóch części. Pierwszą z nich jest serwer API, które zostało stworzone w technologi Ruby on Rails w oparciu o gem rails-api. API jest pośrednikiem między bazą danych \textit{PostgreSQL} a drugą częścią aplikacji czyli klientem stworzonym w EmberJS, który jest odpowiedzialny za warstwę wizualną aplikacji. Obie części komunikują się poprzez \textit{JSON}. Dzięki takiemu rozwiązaniu można stworzyć dodatkowych klientów, na przykład do aplikacji mobilnych.

\section{Użyte technologie}
Część serwerowa aplikacji może zostać wykonana w wielu językach programowania takich jak \textit{Ruby}, \textit{Python}, \textit{JavaScript} czy \textit{PHP}.
Wybrałem język \textit{Ruby}, ponieważ jest on szybkim językiem skryptowym oraz posiada stabilny i sprawdzony \textit{framework} \textit{Ruby on Rails}, który pozwala na szybkie tworzenie aplikacji internetowych oraz dzięki narzędziu \textit{RSpec} na łatwe testowanie kodu.
Spośród mnóstwa technologii do tworzenia interfejsów użytkownika, najbardziej przodujące są oparte te na języku \textit{JavaScript} takie jak \textit{Bootstrap},\textit{ jQuery} czy\\ \textit{AngularJS}. Opierając się na artykułach \cite{} oraz \cite{} postanowiłem wybrać \textit{EmberJS}, \textit{Materialize} oraz \textit{Ruby on Rails}. UI zostanie wykonane w \textit{EmberJS}, jest to  biblioteka  \textit{open-source} języka \textit{JavaScript} stworzona  przez  Yehuda Katz'a  Tom Dale'a, która jest cały czas usprawniana przez społeczność. Posiada ona szereg mechanizmów ułatwiających developerom tworzenie UI na jej podstawie, ma także czytelną i przejrzystą dokumentację. UI aplikacji zostanie dodatkowo upiększone poprzez \textit{framework Materialize}, a \textit{Jasmine} pozwala na testowanie kodu w JavaScript.

\section{API aplikacji}
\subsection{Budowa API w oparciu o Ruby on Rails}
\subsection{Połączenie z bazą danych PostgreSQL}
\textit{PostgreSQL} jest SQL-ową bazą danych, rekomendowaną dla \textit{Ruby on Rails}, przez swoją ścisłą integrację z wcześniej wymienionym \textit{framework}em oraz posiada dobre narzędzia i metody zarządzania. Standardową bazą danych w aplikacjach stworzonych w \textit{Ruby on Rails} jest \textit{SQLite}, jednakże nie jest ona wspierana przez \textit{Heroku}, który jest najpopularniejszym darmowym serwer dla aplikacji w \textit{Ruby on Rails}. Brak wsparcia jest spowodowany tym, że \textit{SQLite} działa głównie w pamięci, i tylko od czasu do czasu zapisuje dane do pliku. O ile takie rozwiązanie jest dobre dla małych lokalnych aplikacji, których dane mogą być łatwo przenoszone, nie sprawdza się na serwerach \textit{Heroku}, gdyż w darmowej wersji, nasza aplikacja może działać maksymalnie przez 18 godzin na dobę po czym jest wyłączana. Takie nagłe wyłączenie spowodowałoby utratę całej bazy danych. Drugim ważnym aspektem jest skalowanie aplikacji. Większy program może zostać uruchomiony na większej ilości zasobów sprzętowych tak zwanych \textit{dyno}, a baza danych \textit{SQLite} może pracować tylko na jednym procesie, tak więc jeśli będzie więcej procesów każdy z nich będzie posiadać własną bazę danych a dane nie będą synchronizowane prawidłowo. W związku z powyższym powinniśmy używać \textit{PostgreSQL} na etapie produkcyjnym naszej aplikacji.\newline \indent Zmiana bazy danych z \textit{SQLite} na \textit{PostgreSQL} nie jest zbyt trudna. Pierwszym krokiem jest zainstalowanie bazy na komputerze, na którym ma być uruchomiona aplikacja. Na oficjalnej stronie można znaleźć linki do pobrania. Po zainstalowaniu, musimy dodać do naszej aplikacji \verb|gem 'pg'| który zapewnia kompatybilność z bazą \textit{PostgreSQL}, a usuwamy \verb|gem 'sqlite3'|. Następnie modyfikujemy plik \textit{database.yml}, który jest plikiem konfiguracyjnym naszej aplikacji. Ostatnim krokiem jest utworzenie bazy danych na nowym środowisku przy pomocy komendy \verb|rake db:create db:migrate|  
\subsection{Dodawanie gemów w Ruby on Rails}
Jedną z największych zalet Ruby on Rails jest dopasowanie się frameworka do naszych potrzeb za pomocą minibibliotek tzw. gemów, tworzonych przez developerów z całego świata.
W sieci można znaleźć tysiące różnych gemów, a każdy z nich posiada przeważnie tylko jedno specyficzne zadanie. Gemy, które są w ciągłym użytku są na bieżąco aktualizowane, dzięki czemu są poprawiane błędy i dodawane nowe funkcje. Przykładowo jeżeli chcemy testować naszą aplikacje, możemy to zrobić dzięki gemowi RSpec. Pozwala on na testowanie różnorakich elementów naszej aplikacji od walidacji pól w formularzach do kontrolerów i zapisywania danych w bazie.\newline \indent Aby dodać nowy gem do naszej aplikacji wystarczy dodać jego nazwę do pliku Gemfile w głównym katalogu naszej aplikacji go zapisać. Następnie wystarczy w terminalu otworzyć folder z naszą aplikacją i wpisać komendę "bundle install". Ruby on Rails automatycznie zainstaluje najnowszą wersję danego gemu, chyba, że wpisaliśmy konkretną wersję w pliku Gemfile. Całość przebiega szybko i sprawnie.

\subsection{Autoryzacja użytkowników}
Autoryzacja użytkowników jest jednym z najważniejszych zagadnień w aplikacji PicDrop. Dzięki niej logujemy się do aplikacji jak i do serwisów społecznościowych, na które chcemy umieścić zdjęcia. Bez niej ktoś obcy mógłby korzystać z naszych danych logowania z Facebooka i Flickr bez naszej wiedzy. Cały proces autoryzacji jest dość skomplikowany i przebiega w kilku etapach. Gdy chcemy się zalogować wpisujemy nasz login i hasło a następnie klikamy na guzik Log in. Nasz login jest adresem email i musi być unikatowy, dlatego mamy pewność, że nie będzie dwóch takich samych kont ale z różnymi hasłami, dzięki czemu nikt się nie zaloguje na nasze konto. \textit{Ember.js} pobiera dane z naszego formularza i wysyła je używając wiadomości \textit{JSON} do naszego serwera. Tam aplikacja generuje dla danego użytkownika klucz tzw. token, który jest przechowywany w bazie danych i na nim opiera się tzw. sesja dzięki, której jesteśmy zalogowani nawet jeśli odświeżymy stronę. Token jest odsyłany do \textit{Ember.js} i jesteśmy zalogowani. \newline \indent Jak pisałem we wcześniejszym rozdziale, aplikacja na serwerze posiada  trzy modele - \textit{User}, \textit{Photo} oraz \textit{Authorization}. Model \textit{User} jest zarządzany przez gem \textit{Devise}. Jest to najpopularniejszy gem do autentykacji w Ruby on Rails. Ma wiele funkcji i składa się z 10 modułów dzięki czemu może być dostosowany do potrzeb developera. Wymienię tylko najważniejsze z nich dla mojej aplikacji. Pierwszy z nich to \textit{Database Authenticatable}, który szyfruje i zachowuje hasło w bazie danych to autoryzacji użytkownika podczas logowania. Drugi to \textit{Omniauthable} dodaje on wsparcie dla OmniAuth, który jest gemem do logowania się w aplikacjach \textit{Ruby on Rails} na różne serwisy społecznościowe. Omówię go dokładniej w następnym rozdziale. Następny to \textit{Timeoutable}, który porzuca sesję dla nieaktywnego użytkownika przez sprecyzowany okres czasu. Takie rozwiązanie znacznie zwiększa bezpieczeństwo naszych danych, ponieważ nawet jeśli zostawimy zalogowany komputer to po czasie wygaśnięcia sesji musimy się ponownie zalogować co nie pozwala użytkować naszego konta przez osoby trzecie.
\newline\indent \textit{Ember.js} do autoryzacji używa biblioteki \textit{Ember Simple Auth} i jej modułu kompatybilnego z \textit{Devise}, który nosi nazwę \textit{Ember Simple Auth Devise}. Biblioteka ta zapewnia komplekowe zarządzanie sesją i logowaniem do aplikacji opartych na \textit{Ember.js}, gdyż posiada wiele modułów dla różnych typów autentykacji. Są to między innymi \textit{simple-auth-oauth2 }, który pozwala na logowanie w standardzie OAuth 2.0. Standard ten jest używany przez Facebooka i zostanie doładniej omówiony w jednym z kolejnych rozdziałów. Kolejny moduł to \textit{simple-auth-torii}. Jest to moduł kompatybilny z biblioteką \textit{Torii}, która odpowiada za logowanie w standardzie OAuth 1a. Standard ten jest wykorzystywany między innymi przez \textit{Twittera} i \textit{Flickra}.

\subsection{Połączenie z API różnych sieci społecznościowych} klucze generowanie, standardy o auth, Omniauth, Torii, logowanie flow, 
Logowanie 

\section{Front-end aplikacji}

\subsection{Budowa Front-endu w oparciu o framework EmberJS }
Warstwa wizualna aplikacji czyli tak zwany front-end został wykonany przy użyciu frameworka EmberJS. Dzięki temu łatwiej zarządzać tą cześcią aplikacji. EmberJS opiera się na wzorcu Model-View-Controler (pol. Model-Widok-Kontroler) co oznacza, że składa się z
trzech podstawowych części opowiedzialnych za różne akcje. Model  jest pewną reprezentacją problemu bądź logiki aplikacji. W naszym przypadku model jest szablonem z opisanymi typami danych danego zasobu np. zdjęcia. Model również komunikuje się z Ember Data czyli warstwą aplikacji bezpośrednio komunikującą się z serwerem.  Widok opisuje, jak wyświetlić pewną część modelu w ramach interfejsu użytkownika. W EmberJS widok składa się z tak zwanych templates czyli kodem HTML z aktywnie zmieniającymi się częściami. Kontroller przyjmuje dane wejściowe od użytkownika i reaguje na jego akcje, zarządzając aktualizacje modelu oraz odświeżenie widoków. Kontroler w EmberJS pobiera dane z modelu oraz zarządza akcjami w widoku.

\subsection{Połączenie z API}
Połączenie z serwerem aplikacji jest jedną z najważniejszych rzeczy w całej aplikacji. To dzięki niemu możemy się komunikować z serwerem oraz przetwarzac dane z bazy danych. EmberJS do pobierania i przetwarzania danych korzysta z biblioteki Ember Data. Ma ona kilka wbudowanych tzw. adapterów do połączenia z różnymi typami serwerów napisanych w różnych językach i technologiach. W mojej aplikacji używam ActiveModelAdapter, który działa bezproblemowo z ActiveModel w Ruby on Rails przeprowadzając serializacje i deserializację danych z EmberJS do wiadomości JSON.

\subsection{Opis narzędzia Ember-CLI}
Ember-CLI (Command Line Interface) to program narzędziowy, który zarządza aplikacją napisaną we frameworku EmberJS. Głównymi zaletami korzystania z tego narzędzia jest zarządzanie plikami, zależnościami, proste dodawanie wtyczek, uruchamianie serwera, generowanie konkretnych części programu jak np. model lub kontroler.

\subsection{Dodawanie wtyczek do aplikacji w EmberJS}
Wtyczki są to programy dodające jakąś funkcjonalność do naszego programu, dzięki czemu nie musimy wszystkich elementów pisać od podstaw. Wystarczy jak poszukamy wtyczki zapewniającej nam funkcjonalność, której szukamy np. t17-ember-upload pozwala na wgrywanie zdjęć do naszej aplikacji porzez proste Drag \& Drop (pol. Przeciągnij i upuść).  Aby dodać wtyczkę wystarczy zainstalować ją przy użyciu NPM lub bowera  po czym dodać app.import w pliku Brocfile.js. Następnie należy zaimportować konkretny moduł z wtyczki do naszej części aplikacji i już można używac widoku oraz akcji z wtyczki.
\subsection{Cross-origin resource sharing} co to , po co, konfiguracja w emberze i railsach
\section{Aplikacja mobilna  na system Android}

\subsection{Zalety aplikacji mobilnej względem strony w mobilnej przeglądarce}
lepiej zagospodarowane miejsce, lepsza kompatybilność 
\subsection{Tworzenie aplikacji przy użyciu narzędzia Cordova}

\chapter{Testy}
\section{Testowanie API przy użyciu RSpec}
\textit{RSpec} jest najpopularniejszą biblioteką używaną do testowania aplikacji napisanych w \textit{Ruby on Rails}. Testy dzielą się na 3 typy. Pierwszy z nich to testy kontrolera, które spawdzają poprawność zapisywania i odczytywania danych w bazie. Dzięki temu wiadomo czy aplikacja prawidłowo komunikuje się z bazą danych. Drugi typ testów to testy modelu danych. Testy te głównie sprawdzają czy walidatory, czyli elementy sprawdzające poprawność i format danych wpisywanych przez użytkownika, działają prawidłowo. Gdyby nie było walidacji, można by było na przykład zamiast imienia wpisać dowolny ciąg znaków o dowolnej długości co może powodować konflikty i błędy podczas przetwarzania danych. Trzeci typ testów to testy funkcjonalne, czyli testy zachowania interfejsu użytkownika na konkretne akcje, jak na przykład wpisanie w pole formularza lub kliknięcie na guzik. Do testów funkcjonalnych często używana jest dodatkowa biblioteka \textit{Capybara}, która współpracuje z Rspec. 
\subsection{Scenariusz testowania}
\subsection{Raport z testów}
\section{Testowanie Front-end przy użyciu Jasmine}
\textit{Jasmine} jest najpopularniejszą biblioteką używaną do testowania aplikacji napisanych w \textit{JavaScript}. 
\subsection{Scenariusz testowania}
\subsection{Raport z testów}
\chapter{Wkład własny}
% zakończenie
\summary
W niniejszej pracy starałem się pokazać budowę aplikacji modularnej, zalety i wady takiego rozwiązania oraz szereg różnych problemów z jakimi musi się uporać developer podczas pisania takowej aplikacji. 
% załączniki (opcjonalnie):
\appendix
\chapter{Tytuł załącznika jeden}

Treść załącznika jeden.
\chapter{Tytuł załącznika dwa}

Treść załącznika dwa.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{mgr}

\nocite {magiaUI}
\nocite {design}
\nocite {projektowanieUI}
\nocite {StiveKrug}
\nocite{DouglasCrockford}
\nocite {UIRails}
\nocite {modelingUI}
\nocite {rspecDoc}
\nocite {railsDoc}
\nocite {emberDoc}
\nocite{emberCLIDoc}
\nocite{emberRails}
\nocite{emberTutorial}
\nocite{emberIntro}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
